using UnityEngine;
using System.Collections;
using Unity.VisualScripting;
using UnityEngine.UI;
using UnityEngine.UIElements;
using UnityEngine.InputSystem;

public class BlockController : MonoBehaviour
{
    public int bx, by;
    private BoardManagerMono board;
    private BoxCollider col;

    private Vector3 basePosition;
    private bool isRaised = false;

    public void Init(int x, int y, BoardManagerMono manager)
    {
        bx = x;
        by = y;
        board = manager;
        col = GetComponent<BoxCollider>();
        basePosition = transform.position;
    }

    public void SetCollider(bool active)
    {
        col.enabled = active;
    }

    public void Raise()
    {
        if (isRaised) return;
        StartCoroutine(RaiseCoroutine());
    }

    public IEnumerator RaiseCoroutine()
    {
        Vector3 startPos = transform.position;
        Vector3 targetPos = basePosition + Vector3.up * 0.5f;
        float t = 0f;
        float duration = 0.2f;

        while (t < 1f)
        {
            t += Time.deltaTime / duration;
            transform.position = Vector3.Lerp(startPos, targetPos, t);
            yield return null;
        }

        isRaised = true;
    }


    public void Lower()
    {
        if (!isRaised) return;
        StartCoroutine(LowerCoroutine());
    }

    public IEnumerator LowerCoroutine()
{
    Vector3 startPos = transform.position;
    Vector3 targetPos = basePosition;
    float t = 0f;
    float duration = 0.2f;

    while (t < 1f)
    {
        t += Time.deltaTime / duration;
        transform.position = Vector3.Lerp(startPos, targetPos, t);
        yield return null;
    }

    isRaised = false;
}


   /*public void Rotate()
    {
        StartCoroutine(RotateRoutine());
    }*/
    public IEnumerator WaitForRaise()
    {
        while (!isRaised)
            yield return null;
    }

    public IEnumerator RotateRoutine(bool clockwise)
    {

        Quaternion startRot = transform.rotation;

        // округляем текущий угол Y к ближайшему кратному 90°
        Vector3 euler = startRot.eulerAngles;
        euler.y = Mathf.Round(euler.y / 90f) * 90f;
        startRot = Quaternion.Euler(euler);

        Quaternion targetRot = startRot * Quaternion.Euler(0, clockwise ? 90f : -90f, 0);

        float t = 0f;
        float duration = 0.3f;
        while (t < 1f)
        {
            t += Time.deltaTime / duration;
            transform.rotation = Quaternion.Slerp(startRot, targetRot, t);
            yield return null;
        }
    }



    /*public IEnumerator RotateRoutine()
    {

        Vector3 startPos = transform.position;
        Vector3 upPos = startPos + Vector3.up * 0.5f;

        float t = 0;
        while (t < 1)
        {
            t += Time.deltaTime / 0.2f;
            transform.position = Vector3.Lerp(startPos, upPos, t);
            yield return null;
        }

        bool clockwise = false;
        bool chosen = false;

        Debug.Log("[Rotate] Press ← or →");

        while (!chosen)
        {
            if (Input.GetKeyDown(KeyCode.LeftArrow)) { clockwise = false; chosen = true; }
            if (Input.GetKeyDown(KeyCode.RightArrow)) { clockwise = true; chosen = true; }
            yield return null;
        }

        board.RotateBlockData(bx, by, clockwise);

        Quaternion from = transform.rotation;
        Quaternion to = from * Quaternion.Euler(0, clockwise ? 90 : -90, 0);

        t = 0;
        while (t < 1)
        {
            t += Time.deltaTime / 0.3f;
            transform.rotation = Quaternion.Slerp(from, to, t);
            yield return null;
        }

        t = 0;
        while (t < 1)
        {
            t += Time.deltaTime / 0.2f;
            transform.position = Vector3.Lerp(upPos, startPos, t);
            yield return null;
        }

        board.OnRotationFinished();
    }*/

    IEnumerator MoveTo(Vector3 target)
    {
        Vector3 start = transform.position;
        float t = 0;

        while (t < 1)
        {
            t += Time.deltaTime / 0.2f;
            transform.position = Vector3.Lerp(start, target, t);
            yield return null;
        }
    }
}
