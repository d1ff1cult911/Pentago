using UnityEngine;
using System.Collections;
using Unity.VisualScripting;
using UnityEngine.UI;
using UnityEngine.UIElements;
using UnityEngine.InputSystem;

public class BlockController : MonoBehaviour
{
    public int bx, by;
    private BoardManagerMono board;
    private BoxCollider col;

    private Vector3 basePosition;
    private bool isRaised = false;

    public void Init(int x, int y, BoardManagerMono manager)
    {
        bx = x;
        by = y;
        board = manager;
        col = GetComponent<BoxCollider>();
        basePosition = transform.position;
    }

    public void SetCollider(bool active)
    {
        col.enabled = active;
    }

    public void Raise()
    {
        if (isRaised) return;
        StartCoroutine(RaiseCoroutine());
    }

    public IEnumerator RaiseCoroutine()
    {
        Vector3 startPos = transform.position;
        Vector3 targetPos = basePosition + Vector3.up * 0.5f;
        float t = 0f;
        float duration = 0.2f;

        while (t < 1f)
        {
            t += Time.deltaTime / duration;
            transform.position = Vector3.Lerp(startPos, targetPos, t);
            yield return null;
        }

        isRaised = true;
    }


    public void Lower()
    {
        if (!isRaised) return;
        StartCoroutine(LowerCoroutine());
    }

    public IEnumerator LowerCoroutine()
{
    Vector3 startPos = transform.position;
    Vector3 targetPos = basePosition;
    float t = 0f;
    float duration = 0.2f;

    while (t < 1f)
    {
        t += Time.deltaTime / duration;
        transform.position = Vector3.Lerp(startPos, targetPos, t);
        yield return null;
    }

    isRaised = false;
}

    public IEnumerator WaitForRaise()
    {
        while (!isRaised)
            yield return null;
    }

    public IEnumerator RotateRoutine(bool clockwise)
    {

        Quaternion startRot = transform.rotation;

        // округляем текущий угол Y к ближайшему кратному 90°
        Vector3 euler = startRot.eulerAngles;
        euler.y = Mathf.Round(euler.y / 90f) * 90f;
        startRot = Quaternion.Euler(euler);

        Quaternion targetRot = startRot * Quaternion.Euler(0, clockwise ? 90f : -90f, 0);

        float t = 0f;
        float duration = 0.3f;
        while (t < 1f)
        {
            t += Time.deltaTime / duration;
            transform.rotation = Quaternion.Slerp(startRot, targetRot, t);
            yield return null;
        }
    }


    IEnumerator MoveTo(Vector3 target)
    {
        Vector3 start = transform.position;
        float t = 0;

        while (t < 1)
        {
            t += Time.deltaTime / 0.2f;
            transform.position = Vector3.Lerp(start, target, t);
            yield return null;
        }
    }
}
