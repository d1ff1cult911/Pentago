using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel.Design.Serialization;
using UnityEngine;
using UnityEngine.UIElements;


public class BoardManagerMono : MonoBehaviour
{
    [Header("AI")]
    [SerializeField] private int aiIndex = 1;
    public bool aiTurnStarted = false;

    private SimplePentagoAI ai;
    [SerializeField] private Canvas winCanvas;
    [SerializeField] private UnityEngine.UI.Text winText;

    public enum GamePhase { PlaceMark,   RotateBlock, GameOver }
    private CellView[,] cellViews;
    public int winLength;
    public bool playWithAI;
    public int blocksPerSide;
    public int blockSize = 3;
    public GameObject boardRoot;
    public bool gameOver = false;
    private CellState winner = CellState.Empty;
    public float gap = 0.2f;
    public float cellSize = 1f;
    public float tableThickness = 0.1f;
    public GamePhase currentPhase = GamePhase.PlaceMark;
    public bool isXTurn = true;

    public int boardSize;
    public CellState[,] board;

    public BlockController[,] blocks;
    public List<BlockController> selectedBlocks = new List<BlockController>();
    private const int maxBlocks = 3;
    public int playerCount;
    public int currentPlayer = 0;

    private Color[] playerColors =
    {
    Color.red,
    Color.blue,
    Color.green,
    Color.yellow
};
    void Start()
    {
        winLength = blocksPerSide;
        boardSize = blocksPerSide * blockSize;
        board = new CellState[boardSize, boardSize];
        blocks = new BlockController[blocksPerSide, blocksPerSide];
        cellViews = new CellView[boardSize, boardSize];
        CreateTable();
        CreateBoard();
        if (playWithAI)
        {
            ai = new SimplePentagoAI(this, aiIndex);
        }
        SetAllBlockColliders(false);

        Debug.Log("[Board] Ready. Phase = PlaceMark");
    }

    void CreateTable()
    {
        GameObject table = GameObject.CreatePrimitive(PrimitiveType.Cube);
        table.name = "Table";

        float size = boardSize * cellSize + (blocksPerSide - 1) * gap;
        table.transform.localScale = new Vector3(size * 1.15f, tableThickness, size * 1.15f);
        table.transform.position = new Vector3(0, -tableThickness / 2f, 0);

        table.GetComponent<MeshRenderer>().material.color =
            new Color(0.6f, 0.3f, 0.1f);

        Destroy(table.GetComponent<BoxCollider>());
    }
    private bool FindWinLine(out List<Vector2Int> winLine)
    {
        winLine = new List<Vector2Int>();

        for (int x = 0; x < boardSize; x++)
        {
            for (int y = 0; y < boardSize; y++)
            {
                CellState state = board[x, y];
                if (state == CellState.Empty)
                    continue;

                if (CollectDirection(x, y, 1, 0, state, out winLine) ||   // ‚Üí
                    CollectDirection(x, y, 0, 1, state, out winLine) ||   // ‚Üì
                    CollectDirection(x, y, 1, 1, state, out winLine) ||   // ‚Üò
                    CollectDirection(x, y, 1, -1, state, out winLine))    // ‚Üó
                {
                    return true;
                }
            }
        }

        winLine.Clear();
        return false;
    }
    private bool CollectDirection(
    int startX,
    int startY,
    int dirX,
    int dirY,
    CellState target,
    out List<Vector2Int> result)
    {
        result = new List<Vector2Int>();

        int x = startX;
        int y = startY;

        while (x >= 0 && x < boardSize && y >= 0 && y < boardSize)
        {
            if (board[x, y] == target)
            {
                result.Add(new Vector2Int(x, y));

                if (result.Count >= winLength)
                    return true;
            }
            else
            {
                result.Clear();
            }

            x += dirX;
            y += dirY;
        }

        result.Clear();
        return false;
    }
    private void HighlightWinLine(List<Vector2Int> line)
    {
        foreach (var pos in line)
        {
            CellView cv = cellViews[pos.x, pos.y];
            cv.StartWinPulse();

        }
    }



    void CreateBoard()
    {
        boardRoot = new GameObject("Board");

        float offset = (boardSize * cellSize + (blocksPerSide - 1) * gap) / 2f;

        for (int bx = 0; bx < blocksPerSide; bx++)
        {
            for (int by = 0; by < blocksPerSide; by++)
            {
                GameObject blockGO = new GameObject($"Block_{bx}_{by}");
                blockGO.transform.parent = boardRoot.transform;

                float px = (bx * blockSize + blockSize / 2f) * cellSize + bx * gap - offset;
                float pz = (by * blockSize + blockSize / 2f) * cellSize + by * gap - offset;
                blockGO.transform.position = new Vector3(px, 0.15f, pz);

                BoxCollider col = blockGO.AddComponent<BoxCollider>();
                col.size = new Vector3(blockSize * cellSize, 1f, blockSize * cellSize);
                col.center = new Vector3(0, 0.5f, 0);

                BlockController bc = blockGO.AddComponent<BlockController>();
                bc.Init(bx, by, this);
                blocks[bx, by] = bc;

                GameObject baseGO = GameObject.CreatePrimitive(PrimitiveType.Cube);
                baseGO.transform.parent = blockGO.transform;
                baseGO.transform.localScale =
                    new Vector3(blockSize * cellSize * 1.03f, 0.1f, blockSize * cellSize * 1.03f);
                baseGO.transform.localPosition = new Vector3(0, -0.05f, 0);
                baseGO.GetComponent<MeshRenderer>().material.color = Color.black;

                Destroy(baseGO.GetComponent<BoxCollider>());

                for (int x = 0; x < blockSize; x++)
                {
                    for (int y = 0; y < blockSize; y++)
                    {
                        int gx = bx * blockSize + x;
                        int gy = by * blockSize + y;


                        GameObject cell = GameObject.CreatePrimitive(PrimitiveType.Cube);
                        cell.name = ($"Cell_{gx}_{gy}");
                        cell.transform.parent = blockGO.transform;
                        cell.transform.localScale =
                            new Vector3(cellSize * 0.95f, 0.02f, cellSize * 0.95f);

                        float cx = (x - blockSize / 2f + 0.5f) * cellSize;
                        float cz = (y - blockSize / 2f + 0.5f) * cellSize;
                        cell.transform.localPosition = new Vector3(cx, 0.02f, cz);

                        CellView cv = cell.AddComponent<CellView>();
                        cv.Init(gx, gy, this);
                        cellViews[gx, gy] = cv;
                    }
                }
            }
        }
    }
    void UpdateCellViewsAfterRotation(int bx, int by, bool clockwise)
    {
        int startX = bx * blockSize;
        int startY = by * blockSize;

        CellView[,] temp = new CellView[blockSize, blockSize];

        for (int x = 0; x < blockSize; x++)
            for (int y = 0; y < blockSize; y++)
                temp[x, y] = cellViews[startX + x, startY + y];

        for (int x = 0; x < blockSize; x++)
        {
            for (int y = 0; y < blockSize; y++)
            {
                int nx = clockwise ? y : blockSize - 1 - y;
                int ny = clockwise ? blockSize - 1 - x : x;

                CellView cv = temp[x, y];
                cellViews[startX + nx, startY + ny] = cv;

                cv.SetCoords(startX + nx, startY + ny);
            }
        }
    }

    public void RotateBlocksData(List<BlockController> blocks, bool clockwise)
    {
        foreach (var b in blocks)
        {
            int bx = b.bx;
            int by = b.by;

            int startX = bx * blockSize;
            int startY = by * blockSize;

            CellState[,] temp = new CellState[blockSize, blockSize];

            for (int x = 0; x < blockSize; x++)
                for (int y = 0; y < blockSize; y++)
                    temp[x, y] = board[startX + x, startY + y];

            for (int x = 0; x < blockSize; x++)
                for (int y = 0; y < blockSize; y++)
                {
                    int nx = clockwise ? y : blockSize - 1 - y;
                    int ny = clockwise ? blockSize - 1 - x : x;
                    board[startX + nx, startY + ny] = temp[x, y];
                }
        }
    }

    private void OnWin(CellState winner)
    {
        gameOver = true;

        Debug.Log($"üèÜ WINNER: {winner}");

        SetAllBlockColliders(false);

        if (FindWinLine(out var line))
        {
            HighlightWinLine(line);
        }
        GameManager.Instance.ShowWin(winner);

    }



    public bool CheckWin()
    {
        winner = CellState.Empty;
        for (int x = 0; x < boardSize; x++)
        {
            for (int y = 0; y < boardSize; y++)
            {
                CellState state = board[x, y];
                if (state == CellState.Empty)
                    continue;

                if (CheckDirection(x, y, 1, 0, state) ||
                    CheckDirection(x, y, 0, 1, state) ||    
                    CheckDirection(x, y, 1, 1, state) ||    
                    CheckDirection(x, y, 1, -1, state))     
                {
                    winner = state;
                    Debug.Log($"[Win] Player {winner} wins starting at {x},{y}");
                    return true;
                }
            }
        }
        return false;
    }

    private bool CheckDirection(int startX, int startY, int dirX, int dirY, CellState target)
    {
        int count = 0;

        int x = startX;
        int y = startY;

        while (x >= 0 && x < boardSize && y >= 0 && y < boardSize)
        {
            if (board[x, y] == target)
            {
                count++;
                if (count >= winLength)
                    return true;
            }
            else
            {
                count = 0;
            }

            x += dirX;
            y += dirY;
        }

        return false;
    }



    public bool CheckWinForPlayer(CellState player)
    {
        for (int x = 0; x < boardSize; x++)
        {
            for (int y = 0; y < boardSize; y++)
            {
                if (board[x, y] != player) continue;

                if (CheckDirection(x, y, 1, 0, player) ||
                    CheckDirection(x, y, 0, 1, player) ||
                    CheckDirection(x, y, 1, 1, player) ||
                    CheckDirection(x, y, 1, -1, player))
                {
                    return true;
                }
            }
        }
        return false;
    }



    void Update()
    {
        if ((currentPhase == GamePhase.PlaceMark && !IsCurrentPlayerAI() && playWithAI == true) | (currentPhase == GamePhase.PlaceMark && playWithAI == false))
        {
            if (!Input.GetMouseButtonDown(0)) return;

            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            if (!Physics.Raycast(ray, out RaycastHit hit)) return;

            CellView cell = hit.transform.GetComponent<CellView>();
            if (cell != null)
            {
                cell.OnClick();
                return;
            }
        }

        if (currentPhase == GamePhase.PlaceMark && IsCurrentPlayerAI() && !aiTurnStarted && playWithAI == true)
        {
            aiTurnStarted = true;
            ai.StartMove();
        }

        if ((currentPhase == GamePhase.RotateBlock && !IsCurrentPlayerAI()&&playWithAI == true)|(currentPhase == GamePhase.RotateBlock &&playWithAI == false))
        {
            if (!Input.GetMouseButtonDown(0)) return;

            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            if (!Physics.Raycast(ray, out RaycastHit hit)) return;

            BlockController block =
                hit.transform.GetComponent<BlockController>() ??
                hit.transform.GetComponentInParent<BlockController>();

            if (block != null)
                SelectBlock(block);
        }
    }
    public bool IsCurrentPlayerAI()
    {
        return currentPlayer == aiIndex;
    }

    public void RotateBlockData(int bx, int by, bool clockwise)
    {

        int startX = bx * blockSize;
        int startY = by * blockSize;

        CellState[,] temp = new CellState[blockSize, blockSize];

        for (int x = 0; x < blockSize; x++)
            for (int y = 0; y < blockSize; y++)
                temp[x, y] = board[startX + x, startY + y];

        for (int x = 0; x < blockSize; x++)
            for (int y = 0; y < blockSize; y++)
            {
                int nx = clockwise ? y : blockSize - 1 - y;
                int ny = clockwise ? blockSize - 1 - x : x;
                board[startX + nx, startY + ny] = temp[x, y];
            }
        UpdateCellViewsAfterRotation(bx, by, clockwise);


        Debug.Log($"[Logic] Block {bx},{by} rotated {(clockwise ? "CW" : "CCW")}");

    }
    public void RotateBlockDataLogicOnly(int bx, int by, bool clockwise)
    {
        int startX = bx * blockSize;
        int startY = by * blockSize;

        CellState[,] temp = new CellState[blockSize, blockSize];

        for (int x = 0; x < blockSize; x++)
            for (int y = 0; y < blockSize; y++)
                temp[x, y] = board[startX + x, startY + y];

        for (int x = 0; x < blockSize; x++)
            for (int y = 0; y < blockSize; y++)
            {
                int nx = clockwise ? y : blockSize - 1 - y;
                int ny = clockwise ? blockSize - 1 - x : x;
                board[startX + nx, startY + ny] = temp[x, y];
            }
    }


    public void SelectBlock(BlockController block)
    {
        if (block == null) return;
        if (selectedBlocks.Contains(block)) return;

        if (selectedBlocks.Count >= maxBlocks)
        {
            return;
        }

        selectedBlocks.Add(block);
        block.Raise();

        if (selectedBlocks.Count == maxBlocks)
        {
            StartCoroutine(RotateSelectedBlocks());
        }
    }

    private IEnumerator RotateSelectedBlocks()
    {
        foreach (var b in selectedBlocks)
            yield return b.WaitForRaise();

        bool clockwise = false;
        bool chosen = false;
        Debug.Log("[Rotate] Press ‚Üê or ‚Üí");
        while (!chosen)
        {
            if (Input.GetKeyDown(KeyCode.LeftArrow)) { clockwise = false; chosen = true; }
            if (Input.GetKeyDown(KeyCode.RightArrow)) { clockwise = true; chosen = true; }
            yield return null;
        }
        DebugPrintBoard("BEFORE ROTATION");


        List<Coroutine> rotations = new List<Coroutine>();
        foreach (var b in selectedBlocks)
        {
            RotateBlockData(b.bx, b.by, clockwise);
            rotations.Add(StartCoroutine(b.RotateRoutine(clockwise)));
        }
        DebugPrintBoard("After Rotation");
        if (CheckWin())
        {
            currentPhase = GamePhase.GameOver;
            StartCoroutine(DelayedWinCoroutine(winner));
        }


        foreach (var r in rotations)
            yield return r;
        DebugPrintBoard("AFTER VISUAL ROTATION");

        List<Coroutine> lowers = new List<Coroutine>();
        foreach (var b in selectedBlocks)
        {
            lowers.Add(StartCoroutine(b.LowerCoroutine()));
        }

        foreach (var l in lowers)
            yield return l;


        selectedBlocks.Clear();
        currentPhase = GamePhase.PlaceMark;

        Debug.Log("[Phase] PlaceMark");

        SetAllBlockColliders(false);
        currentPlayer = (currentPlayer + 1) % playerCount;
        Debug.Log($"[Turn] Current player = {currentPlayer}");

        if (playWithAI && currentPlayer == aiIndex && !aiTurnStarted)
        {
            StartCoroutine(AiTurnCoroutine());
        }
        if (currentPlayer != aiIndex)
        {
            aiTurnStarted = false;
        }

    }
    private IEnumerator DelayedWinCoroutine(CellState winner)
    {
        yield return new WaitForSeconds(0.4f);

        OnWin(winner);
    }

    public void DebugPrintBoard(string label)
    {
        Debug.Log("===== BOARD STATE: " + label + " =====");

        for (int y = boardSize - 1; y >= 0; y--)
        {
            string line = "";
            for (int x = 0; x < boardSize; x++)
            {
                switch (board[x, y])
                {
                    case CellState.Empty: line += ". "; break;
                    case CellState.P1: line += "p1 "; break;
                    case CellState.P2: line += "p2 "; break;
                    default: line += "? "; break;
                }
            }
            Debug.Log(line);
        }

        Debug.Log("=================================");
    }

    private IEnumerator AiTurnCoroutine()
    {
        aiTurnStarted = true;

        yield return new WaitForSeconds(0.5f);

        ai.StartMove();

    }

    public void PlaceMark(int x, int y)
    {
        if (gameOver)
            return;

        if (currentPhase != GamePhase.PlaceMark)
            return;

        if (x < 0 || x >= boardSize || y < 0 || y >= boardSize)
            return;

        if (board[x, y] != CellState.Empty)
            return;

        CellState playerState = (CellState)(currentPlayer + 1);

        board[x, y] = playerState;

        CellView cv = cellViews[x, y];
        cv.SetColor(playerColors[currentPlayer]);

        Debug.Log($"[Move] Player {playerState} at {x},{y}");
        if (CheckWin())
        {
            currentPhase = GamePhase.GameOver;
            StartCoroutine(DelayedWinCoroutine(winner));
            return; 
        }
        currentPhase = GamePhase.RotateBlock;
        SetAllBlockColliders(true);

    }




    public void SetAllBlockColliders(bool active)
    {
        foreach (var b in blocks)
            b.SetCollider(active);
    }
    public bool IsCellEmpty(int x, int y)
    {
        return board[x, y] == CellState.Empty;
    }
    public List<Vector2Int> GetAllEmptyCells()
    {
        List<Vector2Int> result = new List<Vector2Int>();

        for (int x = 0; x < boardSize; x++)
            for (int y = 0; y < boardSize; y++)
                if (board[x, y] == CellState.Empty)
                    result.Add(new Vector2Int(x, y));

        return result;
    }
    public List<List<BlockController>> GetAllBlockTriples()
    {
        List<List<BlockController>> result = new List<List<BlockController>>();

        List<BlockController> all = new List<BlockController>();
        foreach (var b in blocks)
            all.Add(b);

        for (int i = 0; i < all.Count; i++)
            for (int j = i + 1; j < all.Count; j++)
                for (int k = j + 1; k < all.Count; k++)
                    result.Add(new List<BlockController> { all[i], all[j], all[k] });

        return result;
    }

}

