using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel.Design.Serialization;
using UnityEngine;
using UnityEngine.UIElements;


public class BoardManagerMono : MonoBehaviour
{
    [Header("AI")]
    [SerializeField] private int aiIndex = 1;
    public bool aiTurnStarted = false;

    private SimplePentagoAI ai;

    public enum GamePhase { PlaceMark, RotateBlock, GameOver }
    private CellView[,] cellViews;
    public int winLength;
    public bool playWithAI;
    public int blocksPerSide;
    public int blockSize = 3;
    public GameObject boardRoot;
    public bool gameOver = false;
    private CellState winner = CellState.Empty;
    public float gap = 0.2f;
    public float cellSize = 1f;
    public float tableThickness = 0.1f;
    public GamePhase currentPhase = GamePhase.PlaceMark;
    public bool isXTurn = true;

    public int boardSize;
    public CellState[,] board;

    public BlockController[,] blocks;
    public List<BlockController> selectedBlocks = new List<BlockController>();
    private const int maxBlocks = 3;
    public int playerCount;
    public int currentPlayer = 0;

    private Color[] playerColors =
    {
    Color.red,
    Color.blue,
    Color.green,
    Color.yellow
};
    void Start()
    {
        boardSize = blocksPerSide * blockSize;
        board = new CellState[boardSize, boardSize];
        blocks = new BlockController[blocksPerSide, blocksPerSide];
        cellViews = new CellView[boardSize, boardSize];
        CreateTable();
        CreateBoard();
        if (playWithAI)
        {
            ai = new SimplePentagoAI(this, aiIndex);
        }
        SetAllBlockColliders(false);

        Debug.Log("[Board] Ready. Phase = PlaceMark");
    }

    void CreateTable()
    {
        GameObject table = GameObject.CreatePrimitive(PrimitiveType.Cube);
        table.name = "Table";

        float size = boardSize * cellSize + (blocksPerSide - 1) * gap;
        table.transform.localScale = new Vector3(size * 1.15f, tableThickness, size * 1.15f);
        table.transform.position = new Vector3(0, -tableThickness / 2f, 0);

        table.GetComponent<MeshRenderer>().material.color =
            new Color(0.6f, 0.3f, 0.1f);

        Destroy(table.GetComponent<BoxCollider>()); // —Å—Ç–æ–ª—É –∫–æ–ª–ª–∞–π–¥–µ—Ä –Ω–µ –Ω—É–∂–µ–Ω
    }

    void CreateBoard()
    {
        boardRoot = new GameObject("Board");

        float offset = (boardSize * cellSize + (blocksPerSide - 1) * gap) / 2f;

        for (int bx = 0; bx < blocksPerSide; bx++)
        {
            for (int by = 0; by < blocksPerSide; by++)
            {
                GameObject blockGO = new GameObject($"Block_{bx}_{by}");
                blockGO.transform.parent = boardRoot.transform;

                float px = (bx * blockSize + blockSize / 2f) * cellSize + bx * gap - offset;
                float pz = (by * blockSize + blockSize / 2f) * cellSize + by * gap - offset;
                blockGO.transform.position = new Vector3(px, 0.15f, pz);

                BoxCollider col = blockGO.AddComponent<BoxCollider>();
                col.size = new Vector3(blockSize * cellSize, 1f, blockSize * cellSize);
                col.center = new Vector3(0, 0.5f, 0);

                BlockController bc = blockGO.AddComponent<BlockController>();
                bc.Init(bx, by, this);
                blocks[bx, by] = bc;

                // –ü–æ–¥–ª–æ–∂–∫–∞
                GameObject baseGO = GameObject.CreatePrimitive(PrimitiveType.Cube);
                baseGO.transform.parent = blockGO.transform;
                baseGO.transform.localScale =
                    new Vector3(blockSize * cellSize * 1.03f, 0.1f, blockSize * cellSize * 1.03f);
                baseGO.transform.localPosition = new Vector3(0, -0.05f, 0);
                baseGO.GetComponent<MeshRenderer>().material.color = Color.black;

                Destroy(baseGO.GetComponent<BoxCollider>());

                // –ö–ª–µ—Ç–∫–∏
                for (int x = 0; x < blockSize; x++)
                {
                    for (int y = 0; y < blockSize; y++)
                    {
                        int gx = bx * blockSize + x;
                        int gy = by * blockSize + y;


                        GameObject cell = GameObject.CreatePrimitive(PrimitiveType.Cube);
                        cell.name = ($"Cell_{gx}_{gy}");
                        cell.transform.parent = blockGO.transform;
                        cell.transform.localScale =
                            new Vector3(cellSize * 0.95f, 0.02f, cellSize * 0.95f);

                        float cx = (x - blockSize / 2f + 0.5f) * cellSize;
                        float cz = (y - blockSize / 2f + 0.5f) * cellSize;
                        cell.transform.localPosition = new Vector3(cx, 0.02f, cz);

                        CellView cv = cell.AddComponent<CellView>();
                        cv.Init(gx, gy, this);
                        cellViews[gx, gy] = cv;
                    }
                }
            }
        }
    }
    void UpdateCellViewsAfterRotation(int bx, int by, bool clockwise)
    {
        int startX = bx * blockSize;
        int startY = by * blockSize;

        CellView[,] temp = new CellView[blockSize, blockSize];

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ —Å—Å—ã–ª–∫–∏
        for (int x = 0; x < blockSize; x++)
            for (int y = 0; y < blockSize; y++)
                temp[x, y] = cellViews[startX + x, startY + y];

        // –ü–µ—Ä–µ–∫–ª–∞–¥—ã–≤–∞–µ–º
        for (int x = 0; x < blockSize; x++)
        {
            for (int y = 0; y < blockSize; y++)
            {
                int nx = clockwise ? y : blockSize - 1 - y;
                int ny = clockwise ? blockSize - 1 - x : x;

                CellView cv = temp[x, y];
                cellViews[startX + nx, startY + ny] = cv;

                // üî• –û–ë–ù–û–í–õ–Ø–ï–ú –ö–û–û–†–î–ò–ù–ê–¢–´
                cv.SetCoords(startX + nx, startY + ny);
            }
        }
    }

    public void RotateBlocksData(List<BlockController> blocks, bool clockwise)
    {
        foreach (var b in blocks)
        {
            int bx = b.bx; // —Å–¥–µ–ª–∞–π —Å–≤–æ–π—Å—Ç–≤–æ Bx/BY public
            int by = b.by;

            int startX = bx * blockSize;
            int startY = by * blockSize;

            CellState[,] temp = new CellState[blockSize, blockSize];

            // –∫–æ–ø–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
            for (int x = 0; x < blockSize; x++)
                for (int y = 0; y < blockSize; y++)
                    temp[x, y] = board[startX + x, startY + y];

            // –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º
            for (int x = 0; x < blockSize; x++)
                for (int y = 0; y < blockSize; y++)
                {
                    int nx = clockwise ? y : blockSize - 1 - y;
                    int ny = clockwise ? blockSize - 1 - x : x;
                    board[startX + nx, startY + ny] = temp[x, y];
                }
        }
    }

    private void OnWin(CellState winner)
    {
        gameOver = true;

        Debug.Log($"üèÜ WINNER: {winner}");

        SetAllBlockColliders(false);
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã –Ω–∞ –¥–æ—Å–∫–µ
    public bool CheckWin()
    {
        winner = CellState.Empty; // —Å–±—Ä–æ—Å
        for (int x = 0; x < boardSize; x++)
        {
            for (int y = 0; y < boardSize; y++)
            {
                CellState state = board[x, y];
                if (state == CellState.Empty)
                    continue;

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ —á–µ—Ç—ã—Ä–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                if (CheckDirection(x, y, 1, 0, state) ||    // ‚Üí –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å
                    CheckDirection(x, y, 0, 1, state) ||    // ‚Üì –≤–µ—Ä—Ç–∏–∫–∞–ª—å
                    CheckDirection(x, y, 1, 1, state) ||    // ‚Üò –¥–∏–∞–≥–æ–Ω–∞–ª—å –≤–Ω–∏–∑
                    CheckDirection(x, y, 1, -1, state))     // ‚Üó –¥–∏–∞–≥–æ–Ω–∞–ª—å –≤–≤–µ—Ä—Ö
                {
                    winner = state;
                    Debug.Log($"[Win] Player {winner} wins starting at {x},{y}");
                    return true;
                }
            }
        }
        return false;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–π –ª–∏–Ω–∏–∏ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏
    private bool CheckDirection(int startX, int startY, int dirX, int dirY, CellState target)
    {
        int count = 0;

        int x = startX;
        int y = startY;

        while (x >= 0 && x < boardSize && y >= 0 && y < boardSize)
        {
            if (board[x, y] == target)
            {
                count++;
                if (count >= winLength)
                    return true;
            }
            else
            {
                count = 0;
            }

            x += dirX;
            y += dirY;
        }

        return false;
    }



    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ò–ò)
    public bool CheckWinForPlayer(CellState player)
    {
        for (int x = 0; x < boardSize; x++)
        {
            for (int y = 0; y < boardSize; y++)
            {
                if (board[x, y] != player) continue;

                if (CheckDirection(x, y, 1, 0, player) ||
                    CheckDirection(x, y, 0, 1, player) ||
                    CheckDirection(x, y, 1, 1, player) ||
                    CheckDirection(x, y, 1, -1, player))
                {
                    return true;
                }
            }
        }
        return false;
    }



    void Update()
    {
        // -------- –•–û–î –ò–ì–†–û–ö–ê --------
        if ((currentPhase == GamePhase.PlaceMark && !IsCurrentPlayerAI() && playWithAI == true) | (currentPhase == GamePhase.PlaceMark && playWithAI == false))
        {
            if (!Input.GetMouseButtonDown(0)) return;

            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            if (!Physics.Raycast(ray, out RaycastHit hit)) return;

            CellView cell = hit.transform.GetComponent<CellView>();
            if (cell != null)
            {
                cell.OnClick();
                return;
            }
        }

        // -------- –•–û–î –ò–ò --------
        if (currentPhase == GamePhase.PlaceMark && IsCurrentPlayerAI() && !aiTurnStarted && playWithAI == true)
        {
            aiTurnStarted = true;
            ai.StartMove(); // –∑–∞–ø—É—Å–∫–∞–µ—Ç AIMoveRoutine()
        }

        // -------- –í–´–ë–û–† –ë–õ–û–ö–û–í --------
        if ((currentPhase == GamePhase.RotateBlock && !IsCurrentPlayerAI()&&playWithAI == true)|(currentPhase == GamePhase.RotateBlock &&playWithAI == false))
        {
            if (!Input.GetMouseButtonDown(0)) return;

            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            if (!Physics.Raycast(ray, out RaycastHit hit)) return;

            BlockController block =
                hit.transform.GetComponent<BlockController>() ??
                hit.transform.GetComponentInParent<BlockController>();

            if (block != null)
                SelectBlock(block);
        }
    }
    public bool IsCurrentPlayerAI()
    {
        return currentPlayer == aiIndex; // aiPlayerIndex ‚Äî –∏–Ω–¥–µ–∫—Å –ò–ò
    }

    public void RotateBlockData(int bx, int by, bool clockwise)
    {

        int startX = bx * blockSize;
        int startY = by * blockSize;

        CellState[,] temp = new CellState[blockSize, blockSize];

        for (int x = 0; x < blockSize; x++)
            for (int y = 0; y < blockSize; y++)
                temp[x, y] = board[startX + x, startY + y];

        for (int x = 0; x < blockSize; x++)
            for (int y = 0; y < blockSize; y++)
            {
                int nx = clockwise ? y : blockSize - 1 - y;
                int ny = clockwise ? blockSize - 1 - x : x;
                board[startX + nx, startY + ny] = temp[x, y];
            }
        UpdateCellViewsAfterRotation(bx, by, clockwise);


        Debug.Log($"[Logic] Block {bx},{by} rotated {(clockwise ? "CW" : "CCW")}");

    }
    public void RotateBlockDataLogicOnly(int bx, int by, bool clockwise)
    {
        int startX = bx * blockSize;
        int startY = by * blockSize;

        CellState[,] temp = new CellState[blockSize, blockSize];

        for (int x = 0; x < blockSize; x++)
            for (int y = 0; y < blockSize; y++)
                temp[x, y] = board[startX + x, startY + y];

        for (int x = 0; x < blockSize; x++)
            for (int y = 0; y < blockSize; y++)
            {
                int nx = clockwise ? y : blockSize - 1 - y;
                int ny = clockwise ? blockSize - 1 - x : x;
                board[startX + nx, startY + ny] = temp[x, y];
            }
    }


    public void SelectBlock(BlockController block)
    {
        if (block == null) return;
        if (selectedBlocks.Contains(block)) return;

        if (selectedBlocks.Count >= maxBlocks)
        {
            BlockController first = selectedBlocks[0];
            if (first != null)
                first.Lower();
            selectedBlocks.RemoveAt(0);
        }

        selectedBlocks.Add(block);
        block.Raise();

        if (selectedBlocks.Count == maxBlocks)
        {
            StartCoroutine(RotateSelectedBlocks());
        }
    }

    private IEnumerator RotateSelectedBlocks()
    {
        // –ñ–¥–µ–º, –ø–æ–∫–∞ –≤—Å–µ –±–ª–æ–∫–∏ –ø–æ–¥–Ω–∏–º—É—Ç—Å—è
        foreach (var b in selectedBlocks)
            yield return b.WaitForRaise();

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤—Ä–∞—â–µ–Ω–∏—è
        bool clockwise = false;
        bool chosen = false;
        Debug.Log("[Rotate] Press ‚Üê or ‚Üí");
        while (!chosen)
        {
            if (Input.GetKeyDown(KeyCode.LeftArrow)) { clockwise = false; chosen = true; }
            if (Input.GetKeyDown(KeyCode.RightArrow)) { clockwise = true; chosen = true; }
            yield return null;
        }
        DebugPrintBoard("BEFORE ROTATION");


        // –õ–æ–≥–∏—á–µ—Å–∫–∞—è –∏ –≤–∏–∑—É–∞–ª—å–Ω–∞—è —Ä–æ—Ç–∞—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö –±–ª–æ–∫–æ–≤
        List<Coroutine> rotations = new List<Coroutine>();
        // üîπ –õ–æ–≥–∏—á–µ—Å–∫–∞—è —Ä–æ—Ç–∞—Ü–∏—è –≤—Å–µ—Ö –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤
        foreach (var b in selectedBlocks)
        {
            RotateBlockData(b.bx, b.by, clockwise);
            // –≤—ã–∑—ã–≤–∞–µ–º RotateRoutine —Å –≤—ã–±—Ä–∞–Ω–Ω—ã–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º
            rotations.Add(StartCoroutine(b.RotateRoutine(clockwise)));
        }
        DebugPrintBoard("After Rotation");
        // –ø–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ –≤—Å–µ RotateBlockData —É–∂–µ –≤—ã–∑–≤–∞–Ω—ã
        if (CheckWin())
        {
            OnWin(winner);
            yield break;
        }


        // –ñ–¥–µ–º –ø–æ–∫–∞ –≤—Å–µ –±–ª–æ–∫–∏ –ø–æ–≤–µ—Ä–Ω—É—Ç—Å—è
        foreach (var r in rotations)
            yield return r;
        DebugPrintBoard("AFTER VISUAL ROTATION");


        // –û–ø—É—Å–∫–∞–µ–º –≤—Å–µ –±–ª–æ–∫–∏
        List<Coroutine> lowers = new List<Coroutine>();
        foreach (var b in selectedBlocks)
        {
            lowers.Add(StartCoroutine(b.LowerCoroutine())); // LowerCoroutine –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å public
        }

        // –ñ–¥–µ–º –ø–æ–∫–∞ –≤—Å–µ –±–ª–æ–∫–∏ –æ–ø—É—Å—Ç—è—Ç—Å—è
        foreach (var l in lowers)
            yield return l;

        // –ü–æ—Å–ª–µ –≤—Ä–∞—â–µ–Ω–∏—è –æ—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏ –º–µ–Ω—è–µ–º —Ñ–∞–∑—É
        selectedBlocks.Clear();
        currentPhase = GamePhase.PlaceMark;  // –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º X ‚Üî O

        Debug.Log("[Phase] PlaceMark");

        // –í–∫–ª—é—á–∞–µ–º –∫–æ–ª–ª–∞–π–¥–µ—Ä—ã –¥–ª—è –∫–ª–µ—Ç–æ–∫
        SetAllBlockColliders(false); // –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        currentPlayer = (currentPlayer + 1) % playerCount;
        Debug.Log($"[Turn] Current player = {currentPlayer}");

        // ü§ñ –∑–∞–ø—É—Å–∫ –ò–ò, –µ—Å–ª–∏ –µ–≥–æ —Ö–æ–¥
        if (playWithAI && currentPlayer == aiIndex && !aiTurnStarted)
        {
            StartCoroutine(AiTurnCoroutine());
        }
        if (currentPlayer != aiIndex)
        {
            aiTurnStarted = false;
        }

    }
    public void DebugPrintBoard(string label)
    {
        Debug.Log("===== BOARD STATE: " + label + " =====");

        for (int y = boardSize - 1; y >= 0; y--)
        {
            string line = "";
            for (int x = 0; x < boardSize; x++)
            {
                switch (board[x, y])
                {
                    case CellState.Empty: line += ". "; break;
                    case CellState.P1: line += "p1 "; break;
                    case CellState.P2: line += "p2 "; break;
                    default: line += "? "; break;
                }
            }
            Debug.Log(line);
        }

        Debug.Log("=================================");
    }

    private IEnumerator AiTurnCoroutine()
    {
        aiTurnStarted = true;

        yield return new WaitForSeconds(0.5f);

        ai.StartMove();

        // ‚ùó –ù–ï —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –∑–¥–µ—Å—å
    }

    public void PlaceMark(int x, int y)
    {
        if (gameOver)
            return;

        if (currentPhase != GamePhase.PlaceMark)
            return;

        if (x < 0 || x >= boardSize || y < 0 || y >= boardSize)
            return;

        if (board[x, y] != CellState.Empty)
            return;

        CellState playerState = (CellState)(currentPlayer + 1);

        board[x, y] = playerState;

        CellView cv = cellViews[x, y];
        cv.SetColor(playerColors[currentPlayer]);

        Debug.Log($"[Move] Player {playerState} at {x},{y}");

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–±–µ–¥—É
        if (CheckWin())
        {
            OnWin(winner); // –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏–≥—Ä—ã
            currentPhase = GamePhase.GameOver; // –∑–∞–ø—Ä–µ—â–∞–µ–º –¥–∞–ª—å–Ω–µ–π—à–∏–µ —Ö–æ–¥—ã
            return; // –≤—ã—Ö–æ–¥–∏–º ‚Äî –±–æ–ª—å—à–µ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
        }

        // –ï—Å–ª–∏ –ø–æ–±–µ–¥—ã –Ω–µ—Ç, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Ñ–∞–∑–µ –≤—Ä–∞—â–µ–Ω–∏—è
        currentPhase = GamePhase.RotateBlock;
        SetAllBlockColliders(true);

        // –°–º–µ–Ω–∞ –∏–≥—Ä–æ–∫–∞ –±—É–¥–µ—Ç –ø–æ—Å–ª–µ –≤—Ä–∞—â–µ–Ω–∏—è
    }




    public void SetAllBlockColliders(bool active)
    {
        foreach (var b in blocks)
            b.SetCollider(active);
    }
    public bool IsCellEmpty(int x, int y)
    {
        return board[x, y] == CellState.Empty;
    }
    public List<Vector2Int> GetAllEmptyCells()
    {
        List<Vector2Int> result = new List<Vector2Int>();

        for (int x = 0; x < boardSize; x++)
            for (int y = 0; y < boardSize; y++)
                if (board[x, y] == CellState.Empty)
                    result.Add(new Vector2Int(x, y));

        return result;
    }
    public List<List<BlockController>> GetAllBlockTriples()
    {
        List<List<BlockController>> result = new List<List<BlockController>>();

        List<BlockController> all = new List<BlockController>();
        foreach (var b in blocks)
            all.Add(b);

        for (int i = 0; i < all.Count; i++)
            for (int j = i + 1; j < all.Count; j++)
                for (int k = j + 1; k < all.Count; k++)
                    result.Add(new List<BlockController> { all[i], all[j], all[k] });

        return result;
    }

}

